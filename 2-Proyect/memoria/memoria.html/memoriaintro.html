<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" content="#273f79"/><link rel="stylesheet" href="lpdoc.css" type="text/css"/><link rel="stylesheet" href="ciao-htmlfontify.css" type="text/css"/><script type="text/javascript" src="lpdoc-aux.js"></script><title>memoria &mdash; Compresion de Secuencias</title></head><body><div class="lpdoc-page fixleftbar"><a href="#" id="sidebar-toggle-button" class="lpdoc-navbutton"><span id="sidebar-button-arrow">&#9776;</span></a><div id="sidebar" class="lpdoc-sidebar"><div class="lpdoc-nav"><span class="lpdoc-on-right"><a class="lpdoc-navbutton" href="memoria.html">&#x2191;</a><a class="lpdoc-navbutton" href="memoriafulltoc.html">&#x2190;</a><a class="lpdoc-navbutton" href="memoriarefs.html">&#x2192;</a><a class="lpdoc-navbutton" href="memoriasearch.html">&#x1F50D;</a></span><span><a href="memoriafulltoc.html">TOC</a></span></div><hr></hr><ul class="lpdoc-itemize-sectpath"><li><a href="memoria.html">Compresion de Secuencias</a> &raquo;<br/> </li><li><a href=""><strong>memoria</strong></a></li></ul><hr></hr><em>ON THIS PAGE</em><ul><li><a href="#Predicados y explicacion de algoritmos">Predicados y explicacion de algoritmos</a></li><ul><li><a href="#partir(Todo, Parte1, Parte2)">partir(Todo, Parte1, Parte2)</a></li><li><a href="#Explicacion partir(Todo, Parte1, Parte2)">Explicacion partir(Todo, Parte1, Parte2)</a></li><li><a href="#parentesis(Parte, Num, ParteNum)">parentesis(Parte, Num, ParteNum)</a></li><li><a href="#Explicacion parentesis(Parte, Num, ParteNum)">Explicacion parentesis(Parte, Num, ParteNum)</a></li><li><a href="#se_repite(Cs, Parte, Num0, Num)">se_repite(Cs, Parte, Num0, Num)</a></li><li><a href="#Explicacion se_repite(Cs, Parte, Num0, Num)">Explicacion se_repite(Cs, Parte, Num0, Num)</a></li><li><a href="#repeticion(Inicial, Comprimida)">repeticion(Inicial, Comprimida)</a></li><li><a href="#Explicacion repeticion(Inicial, Comprimida)">Explicacion repeticion(Inicial, Comprimida)</a></li><li><a href="#divison(Inicial, Comprimida)">divison(Inicial, Comprimida)</a></li><li><a href="#Explicacion division(Inicial, Comprimida)">Explicacion division(Inicial, Comprimida)</a></li><li><a href="#compresion(Inicial, Comprimida)">compresion(Inicial, Comprimida)</a></li><li><a href="#Explicacion compresion(Inicial, Comprimida)">Explicacion compresion(Inicial, Comprimida)</a></li><li><a href="#mejor_compresion(Inicial, Comprimida)">mejor_compresion(Inicial, Comprimida)</a></li><li><a href="#Explicacion mejor_compresion(Inicial, Comprimida)">Explicacion mejor_compresion(Inicial, Comprimida)</a></li><li><a href="#mejor_compresion_memo(Inicial, Comprimida)">mejor_compresion_memo(Inicial, Comprimida)</a></li><li><a href="#Explicacion mejor_compresion_memo(Inicial, Comprimida)">Explicacion mejor_compresion_memo(Inicial, Comprimida)</a></li></ul><li><a href="#Predicados Auxiliares">Predicados Auxiliares</a></li><ul><li><a href="#get_all_compresions(Inicial, Comprimido)">get_all_compresions(Inicial, Comprimido)</a></li><li><a href="#Explicacion get_all_compresions(Inicial, Comprimida)">Explicacion get_all_compresions(Inicial, Comprimida)</a></li><li><a href="#store_result(X)">store_result(X)</a></li><li><a href="#Explicacion store_result(X)">Explicacion store_result(X)</a></li><li><a href="#limpia_memo">limpia_memo</a></li><li><a href="#Explicacion limpia_memo">Explicacion limpia_memo</a></li><li><a href="#head(List, Head)">head(List, Head)</a></li><li><a href="#Explicacion head(List, Head)">Explicacion head(List, Head)</a></li></ul><li><a href="#Casos de prueba">Casos de prueba</a></li><ul><li><a href="#partir(Todo, Parte1, Parte2)">partir(Todo, Parte1, Parte2)</a></li><li><a href="#parentesis(Parte, Num, ParteNum)">parentesis(Parte, Num, ParteNum)</a></li><li><a href="#se_repite(Cs, Parte, Num0, Num)">se_repite(Cs, Parte, Num0, Num)</a></li><li><a href="#repeticion(Inicial, Comprimida)">repeticion(Inicial, Comprimida)</a></li><li><a href="#compresion(Inicial, Comprimida)">compresion(Inicial, Comprimida)</a></li><li><a href="#comprimir(Inicial, Comprimido)">comprimir(Inicial, Comprimido)</a></li><li><a href="#mejor_compresion_memo(Inicial, Comprimido)">mejor_compresion_memo(Inicial, Comprimido)</a></li></ul><li><a href="#Usage and interface">Usage and interface</a></li><li><a href="#Documentation on exports">Documentation on exports</a></li><li><a href="#Documentation on multifiles">Documentation on multifiles</a></li><li><a href="#Documentation on imports">Documentation on imports</a></li></ul></div><div class="lpdoc-main"><div id=""><h1>memoria</h1>
Compresion de Secuencias es un programa desarrollado con el lenguaje de programacion Ciao Prolog. Este lenguaje de programacion forma parte del paradigma de la programacion logica el cual se estudia en la asignatura de Programacion Declarativa: Logica y restricciones de la ETSIINF UPM.<p>El proyecto consiste en la contruccion de un programa que permita comprimir secuencias de caracteres en secuencias que definan de forma mas compacta las mismas. Así, la secuencia aaaaaaa se comprime en a7. La secuencia original es de longitud siete, la comprimida tiene solo longitud dos. La secuencia ababab, de longitud seis, se comprime en (ab)3, de longitud cinco. Nótese que los paréntesis se cuentan también como caracteres de la secuencia. Solo hacen falta paréntesis si la subsecuencia que se repite es de más de un carácter. Para comprimir secuencias complejas, se hace una division de tal manera que se pueda comprimir las partes divididas para luego juntarlas en el resultado final de la compresion. Por ejemplo, la secuencia aaaaaaa se comprime en la secuencia a7. En la compresión por división se divide la secuencia original en dos partes que a su vez se comprimen por separado y se unen los resultados. Por ejemplo, la secuencia aaaaaaabbbbbbb se comprime en a7b7 (comprimiendo cada parte, a su vez, por repetición). La secuencia aaabaaab se comprime por repetición en (a3b)2 donde la subsecuencia aaab se ha comprimido en a3b por división (y a su vez aaa en a3 por repetición). Los resultados de la compresión (tanto de la secuencia original como de sus subsecuencias) han de ser más cortos que las secuencias iniciales. Así, no es admisible comprimir aa en a2, porque tienen la misma longitud, ni abab en (ab)2, porque esta última es más larga. Las secuencias se representaran como listas de caracteres. Por ejemplo, aaa es [a,a,a] y (ab)3 es [’(’,a,b,’)’,3]. En estas listas los números ocupan una única posición, tengan el numero de dígitos que tengan. Así, a12 es la lista [a,12] y tiene longitud dos (no tres).<p>A continuacion, se detalla el codigo y los predicados utilizados para la resolucion de el enunciado anteriormente expuesto junto con un set de pruebas para asegurar el correcto funcionamiento del codigo.<p><div id="Predicados y explicacion de algoritmos"><h2>Predicados y explicacion de algoritmos</h2> <div id="partir(Todo, Parte1, Parte2)"><h3>partir(Todo, Parte1, Parte2)</h3> <pre class="lpdoc-codeblock">
:- pred partir(Todo, Parte1, Parte2)

Se verifica si @var{Parte1} y @var{Parte2} son dos subsecuencias no vacias que concatenadas forman la secuencia @var{Todo}.@includedef{partir/3}</pre> <p></div><div id="Explicacion partir(Todo, Parte1, Parte2)"><h3>Explicacion partir(Todo, Parte1, Parte2)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Comprobacion de que @var{Parte1} no es una lista vacia.
  2) Comprobacion de que @var{Parte2} no es una lista vacia.
  3) Utilizar el predicado @var{append/2} para encontrar las listas que concatenadas formen la lista @var{Todo}.</pre> <p></div><div id="parentesis(Parte, Num, ParteNum)"><h3>parentesis(Parte, Num, ParteNum)</h3> <pre class="lpdoc-codeblock">
:- pred parentesis(Parte, Num, ParteNum)

Compone la lista de elementos @var{Parte} con el numero de repeticiones dados por la variable @var{Num} envolviendo a esta lista con parentesis solo si esta tiene 2 elementos o mas. @includedef{parentesis/3}</pre> <p></div><div id="Explicacion parentesis(Parte, Num, ParteNum)"><h3>Explicacion parentesis(Parte, Num, ParteNum)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Se checkea que @var{Num} sea efectivamente un numero entero positivo.
  2) Se comprueba el size de la lista @var{Parte} y se bifurca entre size = 1 o size &gt; 1.
  3) Si @var{Parte} es de size 1, se hace un corte para no envolverla en parentesis y se concatena el valor de @var{Parte} con el numero de @var{Num} en @var{ParteNum}.
  4) Si @var{Parte} es de size &gt; 1, se concatenan parentesis por delante y por detras de la lista en @var{ParteNum}.</pre> <p></div><div id="se_repite(Cs, Parte, Num0, Num)"><h3>se_repite(Cs, Parte, Num0, Num)</h3> <pre class="lpdoc-codeblock">
:- pred se_repite(Cs, Parte, Num0, Num)

Se verifica si @var{Cs} se obtiene por repetir N veces la secuencia @var{Parte}. El argumento @var{Num} incrementa @var{Num0} en N. @includedef{se_repite/4}</pre> <p></div><div id="Explicacion se_repite(Cs, Parte, Num0, Num)"><h3>Explicacion se_repite(Cs, Parte, Num0, Num)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Se obtiene en @var{X} la lista que concatenada a @var{Parte} forma la lista completa @var{Cs}.
  2) Se incrementa en @var{Num1} el valor de @var{Num0}.
  3) Se llama recursivamente a se_repite/4 con las variables @var{X}, @var{Parte}, @var{Num1}, @var{Num}.
  4) Cuando @var{Cs} esta vacia, se iguala los valores de @var{Num0} y @var{Num}.</pre> <p></div><div id="repeticion(Inicial, Comprimida)"><h3>repeticion(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
:- pred repeticion(Inicial, Comprimida)

Se basa en los predicados anteriormente detallados @var{partir/3} y @var{se_repite/4}. Este predicado identifica un prefijo que nos de por repeticion la secuencia inicial.
Se comprime de forma recursiva mediante un llamada a @var{compresion_recursiva/2}. Finalmente se debe componer la parte (comprimida recursivamente) con el numero de repeticiones usando el predicado @var{parentesis/3}. @includedef{repeticion/2}</pre> <p></div><div id="Explicacion repeticion(Inicial, Comprimida)"><h3>Explicacion repeticion(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Se llama al predicado @var{partir/2} obteniendo asi una seccion de @var{Inicial} en @var{Parte1}.
  2) Se llama a @var{se_repite/4} para identificar si la seccion @var{Parte1} se repite en el conjunto de @var{Inicial} y de ser asi, cuantas veces lo hace en @var{Num}.
  3) Se llama a @var{compresion_recursiva/2} (posteriormente se hace una llamada a un predicado auxiliar por motivos de eficiencia), obteniendo en @var{X} la secuencia @var{Parte1} comprimida.
  4) Por ultimo se hace una llamada a @var{parentesis/3} para envolver a la secuencia @var{X} con su numero de repeticiones @var{Num} y devolverlo en @var{Comprimida}.</pre> <p></div><div id="divison(Inicial, Comprimida)"><h3>divison(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
:- pred division(Inicial, Comprimida)

Verifica que la lista @var{Inicial} queda dividida en dos partes y llama a @var{compresion_recursiva/2} de forma recursiva para posteriormente concatenar los resultados obtenidos. @includedef{division/2}</pre> <p></div><div id="Explicacion division(Inicial, Comprimida)"><h3>Explicacion division(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Se llama a @var{partir/2} de tal forma que se divide @var{Inicial} en las sublistas @var{X} e @var{Y}.
  2) Se llama a @var{compresion_recursiva/2} obteniendo en @var{X1} la compresion de @var{X}.
  3) Se llama a @var{compresion_recursiva/2} obteniendo en @var{Y1} la compresion de @var{Y}.
  4) Por ultimo, se concatenan las listas @var{X1} e @var{Y1} en la lista @var{Comprimida}.</pre> <p></div><div id="compresion(Inicial, Comprimida)"><h3>compresion(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
:- pred compresion(Inicial, Comprimida)

Llama alternativamente a los predicados @var{repeticion/2} y a @var{division/2} detallados anteriormente.
Esto implica que ademas de considerar las repeticiones, podremos dividir la lista inicial en dos partes y aplicar el algoritmo a cada una de ellas por separado, de esto modo consiguiendo mas posibilidades de encontrar una repeticion. @includedef{compresion/2}</pre> <p></div><div id="Explicacion compresion(Inicial, Comprimida)"><h3>Explicacion compresion(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Si la lista @var{Inicial} cuenta con un solo elemento, @var{Comprimida} pasa a ser este elemento.
  2) Se llama a @var{division/2} con los parametros de entrada de este predicado.
  3) Por otro lado se llama a @var{repeticion/2} con los mismos parametros de entrada de este predicado.</pre> <p></div><div id="mejor_compresion(Inicial, Comprimida)"><h3>mejor_compresion(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
:- pred mejor_compresion(Inicial, Comprimida)

Verifica la busqueda de las compresiones que reduzcan el tamaño. Denotar que en casos de que no sea posible la compresion, se obtendra en @var{Compresion} la lista de entrada @var{Inicial}. Se hace uso del predicado de agregacion @var{findall/3} obteniendo todas las soluciones para postenirmente filtrar la solucion mas corta. @includedef{mejor_compresion/2}.</pre> <p></div><div id="Explicacion mejor_compresion(Inicial, Comprimida)"><h3>Explicacion mejor_compresion(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Se usa el predicado @var{findall/3} desde el que se llama a @var{get_all_compresions/2} para obtener todas las compresiones posibles en @var{Comp_List}.
  2) Se hace uso de @var{sort/2} para odenar las comrpesiones de @var{Comp_List} en funcion del tamaño de sus elementos.
  3) Por ultimo hacemos uso del predicado auxiliar @var{head/2} para obtener el primer elemento de @var{Sorted_List} obteniendo asi la lista con menor tamaño en @var{Comprimido}.</pre> <p></div><div id="mejor_compresion_memo(Inicial, Comprimida)"><h3>mejor_compresion_memo(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
:- pred mejor_compresion_memo(Inicial, Comprimida)

Verifica la busqueda de las compresiones que reduzcan el tamaño implementado un esquema de memorizacion de lemas. Denotar que en casos de que no sea posible la compresion, se obtendra en @var{Compresion} la lista de entrada @var{Inicial}. Se hace uso del predicado de agregacion @var{findall/3} obteniendo todas las soluciones para posteriormente filtrar la solucion mas corta. @includedef{mejor_compresion_memo/2}</pre> <p></div><div id="Explicacion mejor_compresion_memo(Inicial, Comprimida)"><h3>Explicacion mejor_compresion_memo(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Se llama a @var{limpia_memo/0} para borrar los lemas del predicado @var{memo/2}
  1) Se llama a @var{mejor_compresion/2} para encontrar la mejor compresion.
  2) Se hace un corte para no obtener mas compresiones. De no introducir este corte se obtendia una lista de compresiones ordenadas en funcion de su tamaño, lo que es interesante pero no es lo que se pide. @includedef{mejor_compresion_memo}
  NOTA: es importante denotar que el predicado @var{mejor_compresion/2} ya hace uso de la memorizacion de lemas gracias a @var{get_all_compresions/2} por lo que este proceso sera detallado posteriormente en la seccion de predicados auxiliares.</pre> <p></div></div><div id="Predicados Auxiliares"><h2>Predicados Auxiliares</h2> <div id="get_all_compresions(Inicial, Comprimido)"><h3>get_all_compresions(Inicial, Comprimido)</h3> <pre class="lpdoc-codeblock">
:- pred get_all_compresions(Inicial, Comprimido)

Verifica la busqueda de compresiones de la lista @var{Inicial} y guarda de forma dinamica los resultados encontrados. En caso de que una compresion ya haya sido obtenida anteriormente,
esta se descarta. Sim embargo, si estamos ante una nueva compresion, este se guardara dinamicamente como lema del predicado @var{memo/1}. Se ha optado por guardar la compresion en formato Key, Value siendo Key el tamaño de la lista y value la lista en si. @includedef{get_all_compresions/2}</pre> <p></div><div id="Explicacion get_all_compresions(Inicial, Comprimida)"><h3>Explicacion get_all_compresions(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Se llama a @var{sub_compresion_recursiva/2} obteniendo una compresion en @var{New_Comp}.
  2) Si @var{New_Comp} ya ha sido encontrada previamente se failea la busqueda de esta compresion en concreto.
  3) Si @var{New_Comp} no ha sido encontrada previamente, se guarda en @var{memo/1} haciendo uso del predicado @var{store_result/1}
  4) Se haya el tamaño de la lista @var{New_Comp} en @var{CL} haciendo uso del predicado @var{length/2}.
  5) Se verifica que la variable de entrada @var{Comprimido} sea igual al par @var{CL} - @var{New_Comp}.</pre> <p></div><div id="store_result(X)"><h3>store_result(X)</h3> <pre class="lpdoc-codeblock">
:- pred store_result(X)

Guarda de forma dinamica @var{X} como lema del predicado @var{memo/1}.@includedef{store_result/1}</pre> <p></div><div id="Explicacion store_result(X)"><h3>Explicacion store_result(X)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Hacer uso de @var{assert/1} para almacenar dinamicamente el lema @var{X} en el predicado @var{memo/1}.</pre> <p></div><div id="limpia_memo"><h3>limpia_memo</h3> <pre class="lpdoc-codeblock">
:- pred limpia_memo

Elimina la memoria dinamica asiganada a los lemas del predicado @var{memo/1}.@includedef{limpia_memo/0}</pre> <p></div><div id="Explicacion limpia_memo"><h3>Explicacion limpia_memo</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Hacer uso de @var{retractall/1} para eliminar la memoria asiganada los lemas del predicado @var{memo/1}.</pre> <p></div><div id="head(List, Head)"><h3>head(List, Head)</h3> <pre class="lpdoc-codeblock">
:- pred head(List, Head)

Obtiene en @var{Head} el primer elemento de una lista no vacia @var{List}.@includedef{head/2}</pre> <p></div><div id="Explicacion head(List, Head)"><h3>Explicacion head(List, Head)</h3> <pre class="lpdoc-codeblock">
El algoritmo utilizado para este predicado cuenta con los siguientes pasos:
  1) Establecer una igualdad entre el primer elemeto de @var{Lista} y @var{Head}.</pre> <p></div></div><div id="Casos de prueba"><h2>Casos de prueba</h2> <div id="partir(Todo, Parte1, Parte2)"><h3>partir(Todo, Parte1, Parte2)</h3> <pre class="lpdoc-codeblock">

Se comprueba caso erroneo en el que Todo es una lista vacia

:- test partir(Todo, Parte1, Parte2) : (Todo=[]) + fails #&rdquo;No se puede partir una lista vacia&rdquo;.

Se comprueba caso erroneo en el que Todo es una lista de un elemento

:- test partir(Todo, Parte1, Parte2) : (Todo=[a]) + fails #&rdquo;No se puede partir una lista con un solo elemento&rdquo;.

Se comprueba caso valido en el que Todo es una lista con dos elementos (solo debe dar una solucion).

:- test partir(Todo, Parte1, Parte2) : (Todo=[a,b]) + not_fails #&rdquo;Lista dividida satisfactoriamente&rdquo;.

Se comprueba caso valido en el que Todo es una lista con 4 elementos (debe dar todas las soluciones).

:- test partir(Todo, Parte1, Parte2) : (Todo=[a,b,c,d]) + not_fails #&rdquo;Lista dividida satisfactoriamente&rdquo;.</pre> <p></div><div id="parentesis(Parte, Num, ParteNum)"><h3>parentesis(Parte, Num, ParteNum)</h3> <pre class="lpdoc-codeblock">

Se comprueba caso erroneo en el que Parte no es una lista.

:- test parentesis(Parte, Num, ParteNum) : (Parte=1,Num=1) + fails #&rdquo;No se puede aplicar parentesis&rdquo;.

Se comprueba caso erroneo en el que Num no sea un numero.

:- test parentesis(Parte, Num, ParteNum) : (Parte=[a,b,c],Num=a) + fails #&rdquo;No se puede aplicar parentesis&rdquo;.

Se comprueba caso valido para el primer ejemplo del enunciado.

:- test parentesis(Parte, Num, ParteNum) : (Parte=[a,b,c],Num=3) + not_fails #&rdquo;Parentesis aplicado satisfactoriamente&rdquo;.

Se comprueba caso valido para el segundo ejemplo del enunciado.

:- test parentesis(Parte, Num, ParteNum) : (Parte=[a,b],Num=2) + not_fails #&rdquo;Parentesis aplicado satisfactoriamente&rdquo;.

Se comprueba caso valido para el tercer ejemplo del enunciado.

:- test parentesis(Parte, Num, ParteNum) : (Parte=[a],Num=2) + not_fails #&rdquo;Parentesis aplicado satisfactoriamente&rdquo;.</pre> <p></div><div id="se_repite(Cs, Parte, Num0, Num)"><h3>se_repite(Cs, Parte, Num0, Num)</h3> <pre class="lpdoc-codeblock">

Se comprueba caso erroneo en el que Cs no es una lista.

:- test se_repite(Cs, Parte, Num0, Num) : (Cs=1,Parte=[a,b],Num0=0) + fails #&rdquo;No se pudo contar el numero de repeticiones de la subsecuencia&rdquo;.

Se comprueba caso erroneo en el que Parte no es una lista.

:- test se_repite(Cs, Parte, Num0, Num) : (Cs=[a,b],Parte=1,Num0=0) + fails #&rdquo;No se pudo contar el numero de repeticiones de la subsecuencia&rdquo;.

Se comprueba caso erroneo en el que Parte no es subsecuencia de Cs.

:- test se_repite(Cs, Parte, Num0, Num) : (Cs=[a,b,a,b],Parte=[c,d],Num0=0) + fails #&rdquo;No se pudo contar el numero de repeticiones de la subsecuencia&rdquo;.

Se comprueba caso erroneo en el que Parte no es la unica subsecuencia de Cs.

:- test se_repite(Cs, Parte, Num0, Num) : (Cs=[a,b,a,b,c],Parte=[a,b],Num0=0) + fails #&rdquo;No se pudo contar el numero de repeticiones de la subsecuencia&rdquo;.

Se comprueba caso valido en el que se reconoce una secuencia simple.

:- test se_repite(Cs, Parte, Num0, Num) : (Cs=[a,a],Parte=[a],Num0=0) + not_fails #&rdquo;Secuencia reconocida satisfactoriamente&rdquo;.

Se comprueba caso valido en el que se reconoce una secuencia de varios caracteres.

:- test se_repite(Cs, Parte, Num0, Num) : (Cs=[a,b,a,b],Parte=[a,b],Num0=0) + not_fails #&rdquo;Secuencia reconocida satisfactoriamente&rdquo;.

Se comprueba caso valido en el que se reconoce una secuencia con para Num0 distinto de 0.

:- test se_repite(Cs, Parte, Num0, Num) : (Cs=[a,b,a,b],Parte=[a,b],Num0=5) + not_fails #&rdquo;Secuencia reconocida satisfactoriamente&rdquo;.</pre> <p></div><div id="repeticion(Inicial, Comprimida)"><h3>repeticion(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">

Se comprueba caso erroneo en el que no hay repeticiones.

:- test repeticion(Inicial, Comprimida) : (Inicial=[a,b,c]) + fails #&rdquo;No se pudo comprimir la lista por repeticion&rdquo;.

Se comprueba caso valido en el que se repite una secuencia de patrones de 3 caracteres.

:- test repeticion(Inicial, Comprimida) : (Inicial=[a,b,c,a,b,c,a,b,c]) + not_fails #&rdquo;Lista comprimida por repeticion satisfactoriamente&rdquo;.

Se comprueba caso valido en el que se repite una secuencia del mismo caracter.

:- test repeticion(Inicial, Comprimida) : (Inicial=[a,a,a,a,a,a]) + not_fails #&rdquo;Lista comprimida por repeticion satisfactoriamente&rdquo;.

Se comprueba caso valido en el que se repite una secuencia de patrones de 3 caracteres.

:- test repeticion(Inicial, Comprimida) : (Inicial=[a,b,c,a,b,c,a,b,c]) + not_fails #&rdquo;Lista comprimida por repeticion satisfactoriamente&rdquo;.</pre> <p></div><div id="compresion(Inicial, Comprimida)"><h3>compresion(Inicial, Comprimida)</h3> <pre class="lpdoc-codeblock">

Junto con las comprobaciones de compresion se puede testear el correcto funcionamiento de division.

Se comprueba caso valido en el que no se puede comprimir por lo que se devuelve la misma secuencia.

:- test repeticion(Inicial, Comprimida) : (Inicial=[a,b,c]) + not_fails #&rdquo;Secuencia comprimida satisfactoriamente (es la misma que la de entrada)&rdquo;.

Se comprueba caso valido en el que se comprime una secuencia de 3 caracteres 2 veces.

:- test repeticion(Inicial, Comprimida) : (Inicial=[a,b,c,a,b,c]) + not_fails #&rdquo;Secuencia comprimida satisfactoriamente&rdquo;.

Se comprueba caso valido en el que se combina repeticion y division.

:- test repeticion(Inicial, Comprimida) : (Inicial=[a,b,a,b,a,b,c,c,c]) + not_fails #&rdquo;Secuencia comprimida satisfactoriamente (es la misma que la de entrada)&rdquo;.</pre> <p></div><div id="comprimir(Inicial, Comprimido)"><h3>comprimir(Inicial, Comprimido)</h3> <pre class="lpdoc-codeblock">


Se prueba un caso valido en el que no se puede comprimir por lo que se devuelve la misma secuencia.

:- test comprimir(Inicial, Comprimido) : (Inicial=[a,b,c]) + not_fails #&rdquo;Se ha obtenido la secuencia comprimida optima&rdquo;.

Se prueba un caso valido en el que se comprimen secuencias repetidas de 3 caracateres.

:- test comprimir(Inicial, Comprimido) : (Inicial=[a,b,c,a,b,c]) + not_fails #&rdquo;Se ha obtenido la secuencia comprimida optima&rdquo;.

Se prueba un caso valido en el que se comprime por repeticion un solo elemento varias veces.

:- test comprimir(Inicial, Comprimido) : (Inicial=[a,a,a,a,a]) + not_fails #&rdquo;Se ha obtenido la secuencia comprimida optima&rdquo;.

Se prueba un caso valido en el que se comprime por repeticion y por division varios elementos.

:- test comprimir(Inicial, Comprimido) : (Inicial=[a,b,a,b,a,a,a]) + not_fails #&rdquo;Se ha obtenido la secuencia comprimida optima&rdquo;.</pre> <p></div><div id="mejor_compresion_memo(Inicial, Comprimido)"><h3>mejor_compresion_memo(Inicial, Comprimido)</h3> <pre class="lpdoc-codeblock">

Se prueba un caso valido en el que no se puede comprimir por lo que se devuelve la misma secuencia.

:- test mejor_compresion_memo(Inicial, Comprimido) : (Inicial=[a,b,c]) + not_fails #&rdquo;Se ha obtenido la secuencia comprimida optima&rdquo;.

Se prueba un caso valido en el que se comprimen secuencias repetidas de 3 caracateres.

:- test mejor_compresion_memo(Inicial, Comprimido) : (Inicial=[a,b,c,a,b,c]) + not_fails #&rdquo;Se ha obtenido la secuencia comprimida optima&rdquo;.

Se prueba un caso valido en el que se comprime por repeticion un solo elemento varias veces.

:- test mejor_compresion_memo(Inicial, Comprimido) : (Inicial=[a,a,a,a,a]) + not_fails #&rdquo;Se ha obtenido la secuencia comprimida optima&rdquo;.

Se prueba un caso valido en el que se comprime por repeticion y por division varios elementos.

:- test mejor_compresion_memo(Inicial, Comprimido) : (Inicial=[a,b,a,b,a,a,a]) + not_fails #&rdquo;Se ha obtenido la secuencia comprimida optima&rdquo;.</pre> </div></div><br/><div id="Usage and interface"><h2>Usage and interface</h2><div class="lpdoc-cartouche"><ul><li><strong>Library usage:</strong><br/><tt>:- use_module(/home/franser/Documents/uni/3o/Prolog/2-Proyect/memoria/memoria.pl).</tt><li><strong>Exports:</strong><br/><ul class="lpdoc-itemize-minus"><li><em>Predicates:</em><br/><a class="lpdoc-idx-anchor" id="0" href="#alumno_prode/4"><tt>alumno_prode/4</tt></a>, <a class="lpdoc-idx-anchor" id="1" href="#limpia_memo/0"><tt>limpia_memo/0</tt></a>, <a class="lpdoc-idx-anchor" id="2" href="#store_result/1"><tt>store_result/1</tt></a>, <a class="lpdoc-idx-anchor" id="3" href="#compresion_recursiva/2"><tt>compresion_recursiva/2</tt></a>, <a class="lpdoc-idx-anchor" id="4" href="#mejor_compresion_memo/2"><tt>mejor_compresion_memo/2</tt></a>, <a class="lpdoc-idx-anchor" id="5" href="#comprimir/2"><tt>comprimir/2</tt></a>, <a class="lpdoc-idx-anchor" id="6" href="#mejor_compresion/2"><tt>mejor_compresion/2</tt></a>, <a class="lpdoc-idx-anchor" id="7" href="#get_all_compresions/2"><tt>get_all_compresions/2</tt></a>, <a class="lpdoc-idx-anchor" id="8" href="#sub_compresion_recursiva/2"><tt>sub_compresion_recursiva/2</tt></a>, <a class="lpdoc-idx-anchor" id="9" href="#partir/3"><tt>partir/3</tt></a>, <a class="lpdoc-idx-anchor" id="10" href="#parentesis/3"><tt>parentesis/3</tt></a>, <a class="lpdoc-idx-anchor" id="11" href="#se_repite/4"><tt>se_repite/4</tt></a>, <a class="lpdoc-idx-anchor" id="12" href="#repeticion/2"><tt>repeticion/2</tt></a>, <a class="lpdoc-idx-anchor" id="13" href="#compresion/2"><tt>compresion/2</tt></a>, <a class="lpdoc-idx-anchor" id="14" href="#division/2"><tt>division/2</tt></a>, <a class="lpdoc-idx-anchor" id="15" href="#head/2"><tt>head/2</tt></a>.
<li><em>Multifiles:</em><br/><a class="lpdoc-idx-anchor" id="16" href="#call_in_module/2"><tt>call_in_module/2</tt></a>.
</ul></ul></div></div><div id="Documentation on exports"><h2>Documentation on exports</h2><div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="alumno_prode/4" href="memoriasearch.html#alumno_prode/4">alumno_prode/4</a></div><div class="lpdoc-deftext">No further documentation available for this predicate.</div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="memo/1" href="memoriasearch.html#memo/1">memo/1</a></div><div class="lpdoc-deftext">No further documentation available for this predicate.
The predicate is of type <em>dynamic</em>.<br/></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="limpia_memo/0" href="memoriasearch.html#limpia_memo/0">limpia_memo/0</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><p>Elimina los lemas del predicado memo, que son las compresiones encontradas para un secuencia dada como input. <pre class="lpdoc-codeblock">limpia_memo :-
    retractall(memo(_1)).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="store_result/1" href="memoriasearch.html#store_result/1">store_result/1</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>store_result(X)</tt>
</span><p>Guarda de forma dinamica <span class="lpdoc-var">X</span> como lema del predicado <span class="lpdoc-var">memo/1</span>.<pre class="lpdoc-codeblock">store_result(X) :-
    assert(memo(X)).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="compresion_recursiva/2" href="memoriasearch.html#compresion_recursiva/2">compresion_recursiva/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>compresion_recursiva(Inicial,Comprimido)</tt>
</span><p>Comprime las listas y recibe llamadas de forma recursiva. <pre class="lpdoc-codeblock">compresion_recursiva(Inicial,Comprimido) :-
    limpia_memo,
    mejor_compresion(Inicial,Comprimido).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="mejor_compresion_memo/2" href="memoriasearch.html#mejor_compresion_memo/2">mejor_compresion_memo/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>mejor_compresion_memo(Inicial,Comprimido)</tt>
</span><p>Verifica la busqueda de las compresiones que reduzcan el tamaño implementado un esquema de memorizacion de lemas. Denotar que en casos de que no sea posible la compresion, se obtendra en <span class="lpdoc-var">Compresion</span> la lista de entrada <span class="lpdoc-var">Inicial</span>. Se hace uso del predicado de agregacion <span class="lpdoc-var">findall/3</span> obteniendo todas las soluciones para posteriormente filtrar la solucion mas corta. <pre class="lpdoc-codeblock">mejor_compresion_memo(Inicial,Comprimido) :-
    limpia_memo,
    mejor_compresion(Inicial,Comprimido),
    !.
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="comprimir/2" href="memoriasearch.html#comprimir/2">comprimir/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>comprimir(Inicial,Comprimido)</tt>
</span><p>Compresion auxiliar. <pre class="lpdoc-codeblock">comprimir(Inicial,Comprimido) :-
    limpia_memo,
    mejor_compresion(Inicial,Comprimido).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="mejor_compresion/2" href="memoriasearch.html#mejor_compresion/2">mejor_compresion/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>mejor_compresion(Inicial,Comprimido)</tt>
</span><p>Verifica la busqueda de las compresiones que reduzcan el tamaño. Denotar que en casos de que no sea posible la compresion, se obtendra en <span class="lpdoc-var">Compresion</span> la lista de entrada <span class="lpdoc-var">Inicial</span>. Se hace uso del predicado de agregacion <span class="lpdoc-var">findall/3</span> obteniendo todas las soluciones para postenirmente filtrar la solucion mas corta. <pre class="lpdoc-codeblock">mejor_compresion(Inicial,Comprimido) :-
    findall(Y,get_all_compresions(Inicial,Y),Comp_List),
    sort(Comp_List,Sorted_List),
    head(Sorted_List,[_1-Comprimido]).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="get_all_compresions/2" href="memoriasearch.html#get_all_compresions/2">get_all_compresions/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>get_all_compresions(Inicial,Comprimido)</tt>
</span><p>Verifica la busqueda de compresiones de la lista <span class="lpdoc-var">Inicial</span> y guarda de forma dinamica los resultados encontrados. En caso de que una compresion ya haya sido obtenida anteriormente, esta se descarta. Sim embargo, si estamos ante una nueva compresion, este se guardara dinamicamente como lema del predicado <span class="lpdoc-var">memo/1</span>. Se ha optado por guardar la compresion en formato Key, Value siendo Key el tamaño de la lista y value la lista en si. <pre class="lpdoc-codeblock">get_all_compresions(Inicial,Comprimido) :-
    sub_compresion_recursiva(Inicial,New_Comp),
    ( memo(New_Comp) -&gt;
        fail
    ; store_result(New_Comp),
      length(New_Comp,CL),
      Comprimido=[CL-New_Comp]
    ).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="sub_compresion_recursiva/2" href="memoriasearch.html#sub_compresion_recursiva/2">sub_compresion_recursiva/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>sub_compresion_recursiva(Inicial,Comprimido)</tt>
</span><p>Obtiene una compresion unicamente <pre class="lpdoc-codeblock">sub_compresion_recursiva(Inicial,Comprimido) :-
    compresion(Inicial,Comprimido).
sub_compresion_recursiva(Inicial,Inicial).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="partir/3" href="memoriasearch.html#partir/3">partir/3</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>partir(Todo,Parte1,Parte2)</tt>
</span><p>Se verifica si <span class="lpdoc-var">Parte1</span> y <span class="lpdoc-var">Parte2</span> son dos subsecuencias no vacias que concatenadas forman la secuencia <span class="lpdoc-var">Todo</span>.<pre class="lpdoc-codeblock">partir(Todo,Parte1,Parte2) :-
    Parte1=[_1|_2],
    Parte2=[_3|_4],
    append(Parte1,Parte2,Todo).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="parentesis/3" href="memoriasearch.html#parentesis/3">parentesis/3</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>parentesis(Parte,Num,ParteNum)</tt>
</span><p>Compone la lista de elementos <span class="lpdoc-var">Parte</span> con el numero de repeticiones dados por la variable <span class="lpdoc-var">Num</span> envolviendo a esta lista con parentesis solo si esta tiene 2 elementos o mas. <pre class="lpdoc-codeblock">parentesis(Parte,Num,ParteNum) :-
    number(Num),
    length(Parte,1),
    !,
    append(Parte,[Num],ParteNum).
parentesis(Parte,Num,ParteNum) :-
    number(Num),
    append([&apos;(&apos;],Parte,ParteAux),
    append(ParteAux,[&apos;)&apos;,Num],ParteNum).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="se_repite/4" href="memoriasearch.html#se_repite/4">se_repite/4</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>se_repite([],Arg2,Num0,Num0)</tt>
</span><p>Se verifica si <span class="lpdoc-var">Cs</span> se obtiene por repetir N veces la secuencia <span class="lpdoc-var">Parte</span>. El argumento <span class="lpdoc-var">Num</span> incrementa <span class="lpdoc-var">Num0</span> en N. <pre class="lpdoc-codeblock">se_repite([],_1,Num0,Num0).
se_repite(Cs,Parte,Num0,Num) :-
    append(Parte,X,Cs),
    Num1 is Num0+1,
    se_repite(X,Parte,Num1,Num).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="repeticion/2" href="memoriasearch.html#repeticion/2">repeticion/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>repeticion(Inicial,Comprimida)</tt>
</span><p>Se basa en los predicados anteriormente detallados <span class="lpdoc-var">partir/3</span> y <span class="lpdoc-var">se_repite/4</span>. Este predicado identifica un prefijo que nos de por repeticion la secuencia inicial. Se comprime de forma recursiva mediante un llamada a <span class="lpdoc-var">compresion_recursiva/2</span>. Finalmente se debe componer la parte (comprimida recursivamente) con el numero de repeticiones usando el predicado <span class="lpdoc-var">parentesis/3</span>. <pre class="lpdoc-codeblock">repeticion(Inicial,Comprimida) :-
    partir(Inicial,Parte1,_1),
    se_repite(Inicial,Parte1,0,Num),
    sub_compresion_recursiva(Parte1,X),
    parentesis(X,Num,Comprimida).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="compresion/2" href="memoriasearch.html#compresion/2">compresion/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>compresion([X],[X])</tt>
</span><p>Llama alternativamente a los predicados <span class="lpdoc-var">repeticion/2</span> y a <span class="lpdoc-var">division/2</span> detallados anteriormente. Esto implica que ademas de considerar las repeticiones, podremos dividir la lista inicial en dos partes y aplicar el algoritmo a cada una de ellas por separado, de esto modo consiguiendo mas posibilidades de encontrar una repeticion. <pre class="lpdoc-codeblock">compresion([X],[X]) :- !.
compresion(Inicial,Comprimida) :-
    division(Inicial,Comprimida).
compresion(Inicial,Comprimida) :-
    repeticion(Inicial,Comprimida).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="division/2" href="memoriasearch.html#division/2">division/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>division(Inicial,Comprimida)</tt>
</span><p>Verifica que la lista <span class="lpdoc-var">Inicial</span> queda dividida en dos partes y llama a <span class="lpdoc-var">compresion_recursiva/2</span> de forma recursiva para posteriormente concatenar los resultados obtenidos. <pre class="lpdoc-codeblock">division(Inicial,Comprimida) :-
    partir(Inicial,X,Y),
    sub_compresion_recursiva(X,X1),
    sub_compresion_recursiva(Y,Y1),
    append(X1,Y1,Comprimida).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
<div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="head/2" href="memoriasearch.html#head/2">head/2</a></div><div class="lpdoc-deftext"><p><span class="lpdoc-usage-header">Usage:</span><span class="lpdoc-usage-decl"><tt>head([H|_38295],H)</tt>
</span><p>Obtiene en <span class="lpdoc-var">Head</span> el primer elemento de una lista no vacia <span class="lpdoc-var">List</span>.<pre class="lpdoc-codeblock">head([H|_1],H).
</pre></p><ul class="lpdoc-itemize-minus"></ul></div></div><p>
</div><div id="Documentation on multifiles"><h2>Documentation on multifiles</h2><div><div class="lpdoc-defname"><span class="lpdoc-predtag">PREDICATE</span><a class="lpdoc-idx-anchor" id="call_in_module/2" href="memoriasearch.html#call_in_module/2">call_in_module/2</a></div><div class="lpdoc-deftext">No further documentation available for this predicate.
The predicate is <em>multifile</em>.<br/></div></div><p>
</div><div id="Documentation on imports"><h2>Documentation on imports</h2>This module has the following direct dependencies:<ul class="lpdoc-itemize-minus"><li><em>Application modules:</em><br/><a class="lpdoc-idx-anchor" id="17" href="memoriasearch.html#operators"><tt>operators</tt></a>, <a class="lpdoc-idx-anchor" id="18" href="memoriasearch.html#dcg_phrase_rt"><tt>dcg_phrase_rt</tt></a>, <a class="lpdoc-idx-anchor" id="19" href="memoriasearch.html#datafacts_rt"><tt>datafacts_rt</tt></a>, <a class="lpdoc-idx-anchor" id="20" href="memoriasearch.html#dynamic_rt"><tt>dynamic_rt</tt></a>, <a class="lpdoc-idx-anchor" id="21" href="memoriasearch.html#classic_predicates"><tt>classic_predicates</tt></a>, <a class="lpdoc-idx-anchor" id="22" href="memoriasearch.html#iso_misc"><tt>iso_misc</tt></a>, <a class="lpdoc-idx-anchor" id="23" href="memoriasearch.html#lists"><tt>lists</tt></a>, <a class="lpdoc-idx-anchor" id="24" href="memoriasearch.html#sort"><tt>sort</tt></a>.
<li><em>Internal (engine) modules:</em><br/><a class="lpdoc-idx-anchor" id="25" href="memoriasearch.html#term_basic"><tt>term_basic</tt></a>, <a class="lpdoc-idx-anchor" id="26" href="memoriasearch.html#arithmetic"><tt>arithmetic</tt></a>, <a class="lpdoc-idx-anchor" id="27" href="memoriasearch.html#atomic_basic"><tt>atomic_basic</tt></a>, <a class="lpdoc-idx-anchor" id="28" href="memoriasearch.html#basiccontrol"><tt>basiccontrol</tt></a>, <a class="lpdoc-idx-anchor" id="29" href="memoriasearch.html#exceptions"><tt>exceptions</tt></a>, <a class="lpdoc-idx-anchor" id="30" href="memoriasearch.html#term_compare"><tt>term_compare</tt></a>, <a class="lpdoc-idx-anchor" id="31" href="memoriasearch.html#term_typing"><tt>term_typing</tt></a>, <a class="lpdoc-idx-anchor" id="32" href="memoriasearch.html#debugger_support"><tt>debugger_support</tt></a>, <a class="lpdoc-idx-anchor" id="33" href="memoriasearch.html#hiord_rt"><tt>hiord_rt</tt></a>, <a class="lpdoc-idx-anchor" id="34" href="memoriasearch.html#stream_basic"><tt>stream_basic</tt></a>, <a class="lpdoc-idx-anchor" id="35" href="memoriasearch.html#io_basic"><tt>io_basic</tt></a>, <a class="lpdoc-idx-anchor" id="36" href="memoriasearch.html#runtime_control"><tt>runtime_control</tt></a>, <a class="lpdoc-idx-anchor" id="37" href="memoriasearch.html#basic_props"><tt>basic_props</tt></a>.
<li><em>Packages:</em><br/><a class="lpdoc-idx-anchor" id="38" href="memoriasearch.html#prelude"><tt>prelude</tt></a>, <a class="lpdoc-idx-anchor" id="39" href="memoriasearch.html#initial"><tt>initial</tt></a>, <a class="lpdoc-idx-anchor" id="40" href="memoriasearch.html#condcomp"><tt>condcomp</tt></a>, <a class="lpdoc-idx-anchor" id="41" href="memoriasearch.html#classic"><tt>classic</tt></a>, <a class="lpdoc-idx-anchor" id="42" href="memoriasearch.html#runtime_ops"><tt>runtime_ops</tt></a>, <a class="lpdoc-idx-anchor" id="43" href="memoriasearch.html#dcg"><tt>dcg</tt></a>, <a class="lpdoc-idx-anchor" id="44" href="memoriasearch.html#dcg/dcg_phrase"><tt>dcg/dcg_phrase</tt></a>, <a class="lpdoc-idx-anchor" id="45" href="memoriasearch.html#dynamic"><tt>dynamic</tt></a>, <a class="lpdoc-idx-anchor" id="46" href="memoriasearch.html#datafacts"><tt>datafacts</tt></a>, <a class="lpdoc-idx-anchor" id="47" href="memoriasearch.html#assertions"><tt>assertions</tt></a>, <a class="lpdoc-idx-anchor" id="48" href="memoriasearch.html#assertions/assertions_basic"><tt>assertions/assertions_basic</tt></a>.
</ul></div></div><div class="lpdoc-footer">Generated with LPdoc using Ciao</div></div><div class="lpdoc-clearer"></div></div></body></html>